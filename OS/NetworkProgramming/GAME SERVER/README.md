# GAME SERVER
Game Server Programming

## game server theory
온라인 게임에서 로직처리를 한쪽에서 하는 것이 아니라 적절히 서버와 클라이언트가 분배를 해야 함   
모든 로직을 서버에서 처리하면 60프레임(1초에 입력받기, 로칙처리, 렌더링 60번)에 50밀리초의 네트워크 레이턴시가 있다면 렉이 심각해짐   
dedicated server(데디케이티드 서버)는 렌더링과 사용자의 입력 처리를 전혀 받지 않고 순전히 클라이언트의 연결을 받아 세션 처리만 하는 것
### 게임 서버의 품질
#### stability(안전성)
논리적, 물리적 등 모든 위협으로부터 안정성을 확보해야 함
**안정성 확보 방법**
1. 엄격하게 규정된 코딩 가이드라인을 따르고 단순하게 코드를 작성할 것
2. 자동화도니 자가 검증인 unit test(유닛 테스트)를 꼭 만들어서 사용할 것
3. 모든 프로그램 성능의 80%는 20%의 소스 코드에서 나온다는 파레토 법칙을 규정하여 성능에 영향을 주는 코드는 성능을 최적화해서 개발하고 나머지는 유지보수하기 좋은 단순한 구조로 개발하는 것
4. 많은 사람의 코드 리뷰를 해서 문제점을 미리 찾고 지식을 공유할 것
5. 가정하지 말고 스트레스 테스트(Stress Test: bot같은 것을 이용하여 과부하 검증)와 클로즈 베타 테스트(Close Beta Test: 제한된 인원의 검증)와 오픈 베타 테스트(Open Beta Test: 제한 없는 인원의 검증)를 실행하여 검증을 할 것
※ 정식 출시까지의 순서: 유닛 테스트->스트레스 테스트->클로즈 베타 테스트->프리 오픈->출시   
**서버 불안정시 극복 방법**
1. 서버 프로세스가 중단되더라도 다시 자동으로 켜지는 프로그램 만들기, 두 개 동시에 돌림
2. 서버 프로세스를 하나만 띄우는 것이 아니라 여러개로 나누어 띄워 1개가 종료되더라도 적은 수의 사람만 종료되도록 함, 채팅 기능은 다른 서버 프로세스가 담당하도록 하는 것도 방법
3. 분산 서버 구조의 서버 분산 처리로 같은 역할을 하는 서버를 2개 이상 두어 하나가 꺼지면 다른 하나가 자동으로 실행되는 것으로 만듬
4. 항상 서버 에러의 로그(crash dump)를 파일로 남겨 꼭 수정할 것
#### scalability(확장성)
사용자 수가 늘어나더라도 서비스의 품질이 떨어지지 않고 유지되는가를 의미함   
**서버의 확장**
|구분|수직적 확장|수평적 확장|
|:---|:---|:---|
|종류|하드웨어의 성능 업그레이드|서버 개수 증설|
|소프트웨어 설계 비용|낮음|높음|
|확장 비용|기하급수적으로 높아짐|선형적으로 높아짐|
|과부하 지점|서버 컴퓨터 자체|네트워크 장치|
|오류 가능성|로컬 컴퓨터 안에서 동기 프로그래밍 방식으로 작동해서 낮음|여러 컴퓨터에 걸쳐 비동기 프로그래밍 방식으로 작동해서 높음|
|단위 처리 속도|로컬 컴퓨터의 CPU, RAM만 사용해서 높음|여러 서버 컴퓨터간의 메시징이 오가면서 처리하므로 낮음|
|처리 가능 총량|서버 컴퓨터 한 대만 사용해서 낮음|여러 서버 컴퓨터로 부하가 분산되므로 높음|
##### Append Info
1. 서버 간 상호 작용하는 처리에서 성능 하락이나 예전 데이터를 다루는 에러 현상인 stale(스테일)이 발생하기도 함
2. TCP 네트워크 특성상 Nagle 알고리즘을 작용할 수 있음
#### performance(성능)
fps 게임의 경우 0.05초 이상 처리 시간이 걸리면 안되고 바둑 게임의 경우 1초정도 처리 시간이 느려도 괜찮음. 즉, 게임 종류마다 요구되는 성능이 다름   
성능과 확장성의 적절한 밸런스가 필요   
한국에서는 보통 500km 이내에서 1ms안에 메시지가 도달됨   
**서버의 성능을 높이는 방법**
1. 코드 최적화나 알고리즘 최적화를 해서 서버의 단위 처리 속도를 높이는 것
2. 빠른 프로그래밍 언어(c++, rust, go)를 사용하는 것, c는 go로 개발하는 시간과 같은 시간으로 개발할 수 있으면 사용해도 됨
3. 서버 하드웨어 성능을 높임
4. code profiling(코드 프로필링)을 이용해서 서버의 과부하 영역을 분산
5. 메시지의 양을 줄이거나 압축하거나 교환 횟수를 줄이는 네트워크 프로토콜 최적화, 보통 Zlib같은 무손실 압축 알고리즘을 이용하지만 데이터의 단위 크기가 수십 바이트 정도로 작은 데이터는 quantization(양자화)의 압축 기법을 써야 함, 교환 횟수를 줄이는 것이 특히 효과적임   
※ 양자화는 정수나 부동소수점 값의 정밀도를 낮추는 대신 값이 차지하는 데이터의 크기를 줄이는 방법, 플레이어의 체력을 1byte로 줄이거나 네트워크로 주고받을 때만 1byte로 줄이고 게임 프로그램 안에서는 float의 값으로 사용해도 괜찮음
6. 고품질 네트워크 회선을 가진 데이터센터에 서버를 설치해서 네트워크 전송 시간을 줄이는 것도 매우 효과적
7. 지리적으로 가까운 데이터센터에 서버들을 분산해서 설치해 지리적으로 가까운 플레이어끼리 서로 플레이를 하게 유도하는 것도 효과적
8. 서버를 거치지 않고 클라이언트끼리 직접 통신하게 하는 것(P2P 네트워킹)도 효과적. 클라이언트와 서버간 레이턴시가 긴 경우 P2P(Peer-to-Peer) 네트워킹을 사용함, 특히 fps 게임에서 자주 사용하는 기법   
※ P2P 네트워킹은 서버의 부담도 줄이고 비디오 같은 데이터의 양이 클 때 효과적, 그러나 메시지를 검증할 수가 없어 해킹에 약함, 일부 NAT 라우터에 클라이언트끼리 직접 데이터를 주고받을 수 없는 경우도 있어 두 클라이언트 사이에 릴레이를 해 주는 서버가 있어야 할 때도 있음(프라우드넷엔 쉽게 P2P해주는 기능이 있음)
#### 관리의 편의성
일반적인 게임 서버는 실제 서비스시 백그라운드 프로세스를 두어 실행하고 그것을 제어할 수 있는 콘솔이나 GUI 프로그램이나 웹앱(web app) 같은 것을 만들어 사용하기도 함   
※ 백그라운드 프로그램: 윈도우에서는 service(서비스)라 하고 유닉스(linux)에서는 daemon(데몬)이라 함   
**관리 도구의 필수 역할**
1. 서버 켜기 또는 끄기
2. 동시접속자 수 보기
3. CPU, RAM 등 하드웨어 자원 사용량 보기
관리 도구는 조직을 클수록 역할이 GM, SA 등으로 분담됨   
GM(Game Master)은 불량한 행동을 하는 플레이어 강제 추방 등 업무 담당하고 SA(System Administrator)는 서버를 끄거나 켜는 등 업무를 할 수 있음. 즉, 관리도구의 프로그램은 분리되어 각각에 맡기고 서로 같은 업무를 할 수 없음
### 데이터의 저장
단순히 파일시스템을 이용할 순 있지만 요즘에는 대부분 DBMS를 이용한다
#### DBMS의 장점
1. DB의 빠른 검색을 위한 인덱스 기능
2. 데이터의 백업과 복원
3. 트랜잭션을 이용해 예외사항을 원상 복구 할 수 있음(원자성)
4. 잘못된 데이터를 원천 봉쇄 할 수 있음(일관성)
5. DB의 lock기능인 데이터 경쟁 상태에 자유로울 수 있음(고립성)
6. DB의 로그 버퍼 기능으로 장애 직전 상태로 복구 가능(지속성)
### 서버 구동 환경
2000년대 이후에는 윈도우와 epoll의 등장으로 리눅스 모두 서버로 사용함   
서버는 항상 켜져 있어야 하며 인터넷 품질의 신뢰성이 높아야 하고 물리적으로로 안전해야 함   
그래서 데이터센터를 사용하여 직접 하드웨어와 OS를 설치 및 관리(on-premise: 온프리미스, 줄여서 on-prem)를 할 수 있음. 하지만 변화에 빠르게 대응 못하거나 외국에 설치할 경우 출장 등 문제점이 많음   
그래서 가상화를 이용한 클라우드 서버가 등장함. 클라우드 서버는 온프리미스 서버의 문제를 대부분 해결하지만 높은 비용(TCO(Total Cost of Ownership)는 낮을 수 있음)과 가상화 환경이기 때문에 지연 시간이 발생하기도 함.   
따라서 레이턴시가 민감한 게임은 데이터센터와 클라우드 서버를 동시에 이용함   
최근에는 Docker를 사용하여 시스템만 가상화 해서 빠르게 구동 가능함
```
    클라우드 서버 계층

    IaaS(Infrastructure as a Service) - 가상 머신 자체를 제공해서 필요한 소프트웨어는 모두 직접 설치해서 운영해야 함
    PaaS(Platform as a Service) - 가상 머신과 OS와 필요한 소프트웨어가 미리 구동되어 있고 필요한 서버 코드나 데이터 파일을 업로드해서 바로 사용할 수 있음
    SaaS(Software as a Service) - 코딩 자체가 필요 없고 데이터 분석이나 페이스북 로그인 등 특화 된 기능들을 미리 제공함
```
#### 결론
아무 기술을 써도 되고 새로운 기술을 연구해도 되지만 실제 서비스에서는 안정적인 코드와 서비스, 보수적인 개발을 필수로 해야함
## game server network engine
### ProudNet (프라우드넷)
상업용 네트워크 엔진
